'''
Created on Oct 1, 2014

@author: fabiomignini
'''
from orchestrator_core.exception import NodeNotFound
from orchestrator_core.sql.node import Node
from orchestrator_core.sql.graph import Graph
from orchestrator_core.sql.domains_info import DomainsInformation
import itertools

import logging

class Scheduler(object):
    def __init__(self):
        pass
    
    def schedule(self, nffg):
        node_list = []
        nffg_list = []      
        node = Node().getNodeFromDomainID(self.checkEndpointLocation(nffg))
        node_list.append(node)
        nffg_list.append(nffg)
        
        # check if the nffg can be split (for the moment with a very stupid criterion)
        left = []
        right = []
        splittable = False
        for endpoint in nffg.end_points:
            if endpoint.type == 'interface' and endpoint.name == "user":
                splittable = True
                left.append(endpoint)
                right = nffg.end_points + nffg.vnfs
                right.remove(endpoint)
                break
        # Try to split and match capabilities
        if splittable is True:
            domains_info = DomainsInformation().get_domain_info()
            if not domains_info:
                logging.debug("Domains information are not present, so it's not possible to split the graph")
                return node_list, nffg_list
            if node.id not in domains_info:
                logging.debug("Domain information related to the user endpoint node are not available, so it's not possible to split the graph")
                return node_list, nffg_list
            nffg1, nffg2 = nffg.split(left, right)
            #print(nffg1.getJSON())
            #print(nffg2.getJSON())
            gen_endpoints = nffg1.getAutogeneratedEndpoints()

            characterization = self.matchCapabilites(domains_info, len(gen_endpoints), node.id)
            
            if characterization:
                logging.debug("Graph can be split!")
                self.characterizeEndpoints(nffg1, nffg2, gen_endpoints, characterization)
                nffg_list.clear()
                nffg_list.append(nffg1)   
                nffg_list.append(nffg2)  
                # provisional
                node_list.append(Node().getNodeFromDomainID(self.checkEndpointLocation(nffg2)))
            else:
                logging.debug("Graph cannot be split because domains capabilities are not suitable for this graph")
            
        return node_list, nffg_list
    
    def characterizeEndpoints(self, nffg1, nffg2, gen_endpoints, characterization):
        #nffg1 will be instantiated in the domain that contains the user_endpoint
        i=0
        for element in characterization:
            if type(element) is DirectLink:
                nffg_1_endp = nffg1.getEndPoint(gen_endpoints[i].id)
                nffg_2_endp = nffg2.getEndPoint(gen_endpoints[i].id)
                #Characterization of single endpoints
                nffg_1_endp.type = "interface"
                nffg_1_endp.node_id = Node().getNode(element.domain_1).domain_id
                nffg_1_endp.interface = element.port_1
                nffg_2_endp.type = "interface"
                nffg_2_endp.node_id = Node().getNode(element.domain_2).domain_id
                nffg_2_endp.interface = element.port_2                
            else:
                raise TypeError("Only DirectLink characterizations are supported")
            i=i+1
        #print(nffg1.getJSON())
        #print(nffg2.getJSON())         
        
    def matchCapabilites(self, domains_info, number_of_links, user_endpoint_node_id):
        # Can be done in a more elegant way
        characterization = None
        for domain_relationship in itertools.permutations(domains_info, 2):
            #print(domain_relationship)
            if domain_relationship[0]==user_endpoint_node_id :
                print(domain_relationship)
                characterization = self.searchMatchesBetweenDomains(domains_info, domain_relationship[0], domain_relationship[1], number_of_links)
                if characterization:
                    break
        return characterization
                
    def searchMatchesBetweenDomains(self, domains_info, node_id_1, node_id_2, number_of_links):
        matches_found = 0
        #only direct links currently supported
        characterization = []
        domain_1 = domains_info[node_id_1]
        for interface in domain_1.interfaces:
            #Check if a direct link between these two domains exists
            try:
                if interface.neighbor_domain is not None and interface.neighbor_domain != "internet":
                    remote_node = Node().getNodeFromName(interface.neighbor_domain)
                    remote_interface_name = interface.neighbor_interface
                    if remote_node.id == node_id_2 and remote_node.id in domains_info:
                        remote_interface = domains_info[remote_node.id].getInterface(remote_interface_name)
                        if remote_interface is not None and remote_interface.neighbor_domain == Node().getNode(node_id_1).name and remote_interface.neighbor_interface == interface.name:
                            #Direct link found between these two domains
                            print ("match found")
                            matches_found = matches_found + 1
                            characterization.append(DirectLink(node_id_1, interface.name, node_id_2, remote_interface_name))
                            if matches_found == number_of_links:
                                break
            except NodeNotFound:
                pass
        if matches_found == number_of_links:
            print ("Characterization found")
            return characterization
        else:
            return None
                            
    def checkEndpointLocation(self, nffg):
        '''
        Define the node where to instantiate the nffg
        '''
        node = None
        for end_point in nffg.end_points:
            if end_point.node_id is not None:
                node = end_point.node_id
                break
            elif end_point.switch_id is not None:
                node = end_point.switch_id
                break
        if node is None:
            raise NodeNotFound("Unable to determine where to place this graph (endpoint.node_id or endpoint.switch_id missing)")
        return node
    
class DirectLink(object):
    def __init__(self, domain_1=None, port_1=None, domain_2=None, port_2=None):
        self.domain_1 = domain_1
        self.port_1 = port_1
        self.domain_2 = domain_2
        self.port_2 = port_2        
        
        
        
