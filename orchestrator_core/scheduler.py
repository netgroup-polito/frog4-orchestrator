'''
Created on Oct 1, 2014

@author: fabiomignini
'''
from orchestrator_core.exception import NodeNotFound, DomainNotFound
from orchestrator_core.sql.graph import Graph
from orchestrator_core.sql.domain import Domain
from orchestrator_core.sql.domains_info import DomainInformation
import itertools, random
import logging
from collections import OrderedDict

class Scheduler(object):
    def __init__(self):
        pass
    
    def schedule(self, nffg):
        domain_list = []
        nffg_list = [] 
        if nffg.domain is not None:
            domain = Domain().getDomainFromName(nffg.domain)
        else:
            # Guess the domain
            domain_id = self.checkEndpointLocation(nffg)
            if domain_id is None:
                raise DomainNotFound("I don't know where to instantiate the NF-FG.")
            domain = Domain().getDomain(domain_id)
        domain_list.append(domain)
        nffg_list.append(nffg)
        
        # check if the nffg can be split (for the moment with a very stupid criterion)
        left = []
        right = []
        splittable = False
        for endpoint in nffg.end_points:
            if endpoint.type == 'interface' and endpoint.name == "user":
                splittable = True
                left.append(endpoint)
                right = nffg.end_points + nffg.vnfs
                right.remove(endpoint)
                break
        # Try to split and match capabilities
        if splittable is True:
            domains_info = DomainInformation().get_domain_info()
            if not domains_info:
                logging.debug("Domains information are not present, so it's not possible to split the graph")
                return domain_list, nffg_list
            if domain.id not in domains_info:
                logging.debug("Domain information related to the user endpoint domain are not available, so it's not possible to split the graph")
                return domain_list, nffg_list
            nffg1, nffg2 = nffg.split(left, right)

            gen_endpoints = nffg1.getAutogeneratedEndpoints()

            characterization = self.matchCapabilites(domains_info, len(gen_endpoints), domain.id)
            
            if characterization is not None:
                logging.debug("Graph can be split!")
                self.characterizeEndpoints(nffg1, nffg2, gen_endpoints, characterization)
                nffg_list.clear()
                nffg_list.append(nffg1)   
                nffg_list.append(nffg2)  
                # provisional
                domain_list.append(Domain().getDomain(self.checkEndpointLocation(nffg2)))
            else:
                logging.debug("Graph cannot be split because domains capabilities are not suitable for this graph")
            
        return domain_list, nffg_list
    
    def characterizeEndpoints(self, nffg1, nffg2, gen_endpoints, characterization):
        #nffg1 will be instantiated in the domain that contains the user_endpoint
        i=0
        for element in characterization:
            if type(element) is DirectLink:
                nffg_1_endp = nffg1.getEndPoint(gen_endpoints[i].id)
                nffg_2_endp = nffg2.getEndPoint(gen_endpoints[i].id)
                
                nffg_1_endp.type = "interface"
                if element.domain_1_type == "ODL":
                    nffg_1_endp.switch_id = element.node_1
                else:
                    nffg_1_endp.node_id = element.node_1
                nffg_1_endp.interface = element.port_1
                nffg_2_endp.type = "interface"
                if element.domain_2_type == "ODL":
                    nffg_2_endp.switch_id = element.node_2
                else:
                    nffg_2_endp.node_id = element.node_2
                nffg_2_endp.interface = element.port_2
            elif type(element) is Vlan:
                nffg_1_endp = nffg1.getEndPoint(gen_endpoints[i].id)
                nffg_2_endp = nffg2.getEndPoint(gen_endpoints[i].id)
                
                nffg_1_endp.type = "vlan"
                if element.domain_1_type == "ODL":
                    nffg_1_endp.switch_id = element.node_1
                else:
                    nffg_1_endp.node_id = element.node_1
                nffg_1_endp.interface = element.port_1
                nffg_1_endp.vlan_id = str(element.vlan)
                nffg_2_endp.type = "vlan"
                if element.domain_2_type == "ODL":
                    nffg_2_endp.switch_id = element.node_2
                else:
                    nffg_2_endp.node_id = element.node_2
                nffg_2_endp.interface = element.port_2         
                nffg_2_endp.vlan_id = str(element.vlan)
            elif type(element) is Gre:
                nffg_1_endp = nffg1.getEndPoint(gen_endpoints[i].id)
                nffg_2_endp = nffg2.getEndPoint(gen_endpoints[i].id)
                ip_1 = element.node_1
                ip_2 = element.node_2
                
                nffg_1_endp.type = "gre-tunnel"
                nffg_1_endp.local_ip = ip_1
                nffg_1_endp.remote_ip = ip_2
                nffg_1_endp.interface = element.port_1
                nffg_1_endp.gre_key = element.gre_key
                nffg_2_endp.type = "gre-tunnel"
                nffg_2_endp.local_ip = ip_2
                nffg_2_endp.remote_ip = ip_1                
                nffg_2_endp.interface = element.port_2         
                nffg_2_endp.gre_key = element.gre_key     
            else:
                raise TypeError("Only DirectLink, Vlan and Gre characterizations are supported")
            i=i+1
        #print(nffg1.getJSON())
        #print(nffg2.getJSON())         
        
    def matchCapabilites(self, domains_info, number_of_links, user_endpoint_domain_id):
        characterizations_score = []
        characterizations_list = []
        ordered_domains_info = OrderedDict()
        ordered_domains_info[user_endpoint_domain_id] = domains_info[user_endpoint_domain_id]
        del domains_info[user_endpoint_domain_id]
        for k, v in domains_info.items():
            ordered_domains_info[k] = v
        
        for domain_relationship in itertools.combinations(ordered_domains_info, 2):
            #print(domain_relationship)
            if domain_relationship[0] == user_endpoint_domain_id:
                print(domain_relationship)
                characterization = self.searchMatchesBetweenDomains(ordered_domains_info, domain_relationship[0], domain_relationship[1], number_of_links)
                if characterization is not None:
                    characterizations_list.append(characterization)
                    characterizations_score.append(self.calculateScore(characterization))
        if len(characterizations_list) == 0:
            return None
        return characterizations_list[characterizations_score.index(max(characterizations_score))]
                
    def searchMatchesBetweenDomains(self, domains_info, domain_id_1, domain_id_2, number_of_links):
        matches_found = 0
        characterization = []
        domain_1 = domains_info[domain_id_1]
        #Vlan
        for interface in domain_1.interfaces: 
            for neighbor in interface.neighbors:
                if neighbor.domain_name != "internet" and neighbor.node is not None and neighbor.interface is not None:
                    #Search for direct connections
                    try:
                        remote_domain = Domain().getDomainFromName(neighbor.domain_name)
                    except DomainNotFound:
                        #Remote_domain not found, continue
                        continue     
                    remote_node = neighbor.node
                    remote_interface_name = neighbor.interface
                    if remote_domain.id == domain_id_2 and remote_domain.id in domains_info:
                        remote_interface = domains_info[remote_domain.id].getInterface(remote_node, remote_interface_name)
                        if remote_interface is not None and self.isNeighbor(remote_interface, Domain().getDomain(domain_id_1).name, interface) is True:
                            if interface.vlan is True and remote_interface.vlan is True:
                                while matches_found < number_of_links:
                                    vlan_id = self.findFreeVlanId(interface.vlans_used, remote_interface.vlans_used)
                                    if vlan_id is not None:
                                        print ("vlan match found")
                                        matches_found = matches_found + 1
                                        characterization.append(Vlan(interface.node, interface.name, domain_1.type, remote_node, remote_interface_name, remote_domain.type, vlan_id))
                                    else:
                                        break
                                if matches_found == number_of_links:
                                    break
            if matches_found == number_of_links:
                break
        #Direct links
        if matches_found < number_of_links:
            for interface in domain_1.interfaces:
                for neighbor in interface.neighbors: 
                    if neighbor.domain_name != "internet" and neighbor.node is not None and neighbor.interface is not None:
                        #Search for direct connections
                        try:
                            remote_domain = Domain().getDomainFromName(neighbor.domain_name)
                        except DomainNotFound:
                            #Remote_domain not found, continue
                            continue
                        remote_node = neighbor.node         
                        remote_interface_name = neighbor.interface                   
                        if remote_domain.id == domain_id_2 and remote_domain.id in domains_info:
                            remote_interface = domains_info[remote_domain.id].getInterface(remote_node, remote_interface_name)
                            if remote_interface is not None and self.isNeighbor(remote_interface, Domain().getDomain(domain_id_1).name, interface) is True:
                                print ("direct link match found")
                                matches_found = matches_found + 1
                                characterization.append(DirectLink(interface.node, interface.name, domain_1.type, remote_node, remote_interface_name, remote_domain.type))
                                if matches_found == number_of_links:
                                    break
                if matches_found == number_of_links:
                    break
        #GRE
        if matches_found < number_of_links:
            #Search for internet connections
            for interface in domain_1.interfaces: 
                if self.hasInternetConnectivity(interface) is True and interface.gre is True:
                    #if self.checkActiveTunnels(interface, node_id_2) is True:
                    domain_2 = domains_info[domain_id_2]
                    for remote_interface in domain_2.interfaces:
                        if self.hasInternetConnectivity(remote_interface) is True and remote_interface.gre is True:
                            #Gre_tunnel endpoints found                            
                            while matches_found < number_of_links:
                                print ("gre match found")
                                matches_found = matches_found + 1
                                characterization.append(Gre(interface.node, interface.name, remote_interface.node, remote_interface.name))
                            break   
                if matches_found == number_of_links:
                    break                       

        if matches_found == number_of_links:
            print ("Characterization found")
            return characterization
        else:
            return None       
                            
    def checkEndpointLocation(self, nffg):
        '''
        Define the node where to instantiate the nffg
        '''
        # TODO: scan until a valid node is found 
        domain_info = DomainInformation()
        node = None
        for end_point in nffg.end_points:
            if end_point.node_id is not None:
                node = end_point.node_id
                break
            elif end_point.switch_id is not None:
                node = end_point.switch_id
                break
            elif end_point.local_ip is not None:
                node = end_point.local_ip
                break
        if node is None:
            raise NodeNotFound("Unable to determine where to place this graph (endpoint.node_id or endpoint.switch_id or endpoint.local_ip missing)")
        return domain_info.getDomainIDfromNode(node)
    
    def findFreeVlanId(self, vlans_used_1, vlans_used_2):
        vlan_id = 2
        while (vlan_id < 4095):
            if vlan_id not in vlans_used_1 and vlan_id not in vlans_used_2:
                vlans_used_1.append(vlan_id)
                vlans_used_2.append(vlan_id)
                return vlan_id
            vlan_id = vlan_id + 1
            
    def calculateScore(self, characterization):
        #TODO: different score if multiple characterizations over the same interface?
        vlan_value = 3
        directlink_value = 2
        gre_value = 1
        
        score=0
        for element in characterization:
            if type(element) is DirectLink:
                score = score + directlink_value
            elif type(element) is Vlan:
                score = score + vlan_value
            elif type(element) is Gre:
                score = score + gre_value                
        return score
    
    def isNeighbor(self, interface_1, domain_name_2, interface_2):
        '''
        Determines whether among the neighbors of interface_1 there is interface_2 of domain_name_2 
        '''
        for neighbor in interface_1.neighbors:
            if neighbor.domain_name == domain_name_2 and neighbor.node == interface_2.node and neighbor.interface == interface_2.name:
                return True
        return False
    
    def hasInternetConnectivity(self, interface):
        '''
        Determines whether interface is connected to the Internet
        '''
        for neighbor in interface.neighbors:
            if neighbor.domain_name == "internet":
                return True
        return False
        
    """
    def checkActiveTunnels(self, interface, remote_domain_id):
        '''
        Returns True if this interface is not already connected to the remote domain
        '''
        return True
        '''
        for gre_tunnel in interface.gre_tunnels:
            if gre_tunnel.remote_ip == Node().getNode(remote_domain_id).domain_id:
                return False
        return True
        '''
    
    def checkTunnelEndpoint(self, domain_id, interface, characterization):
        '''
        Returns False if this interface is already in a Gre characterization
        '''
        for element in characterization:
            if type(element) is Gre and element.domain_2 == domain_id and element.port_2 == interface.name:
                return False
        return True
    """
class DirectLink(object):
    def __init__(self, node_1=None, port_1=None, domain_1_type = None, node_2=None, port_2=None, domain_2_type=None):
        self.node_1 = node_1
        self.port_1 = port_1
        self.domain_1_type = domain_1_type
        self.node_2 = node_2
        self.port_2 = port_2
        self.domain_2_type = domain_2_type

           
class Vlan(object):
    def __init__(self, node_1=None, port_1=None, domain_1_type = None, node_2=None, port_2=None, domain_2_type=None, vlan=None):
        self.node_1 = node_1
        self.port_1 = port_1
        self.domain_1_type = domain_1_type        
        self.node_2 = node_2
        self.port_2 = port_2 
        self.domain_2_type = domain_2_type        
        self.vlan = vlan
        
class Gre(object):
    def __init__(self, node_1=None, port_1=None, node_2=None, port_2=None, gre_key=None):
        self.node_1 = node_1
        self.port_1 = port_1
        self.node_2 = node_2
        self.port_2 = port_2 
        if gre_key is not None:
            self.gre_key = gre_key
        else:
            self.gre_key = '%032x' % random.getrandbits(128)
