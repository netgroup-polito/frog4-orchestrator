'''
Created on Oct 1, 2014

@author: fabiomignini
'''
from orchestrator_core.exception import NodeNotFound
from orchestrator_core.sql.node import Node
from orchestrator_core.sql.graph import Graph
from orchestrator_core.sql.domains_info import DomainsInformation
import itertools

import logging

class Scheduler(object):
    def __init__(self):
        pass
    
    def schedule(self, nffg):
        node_list = []
        nffg_list = []      
        node = Node().getNodeFromDomainID(self.checkEndpointLocation(nffg))
        node_list.append(node)
        nffg_list.append(nffg)
        # not needed in UN
        #self.changeAvailabilityZone(nffg, Node().getAvailabilityZone(node.id))
        
        # check if the nffg can be split (for the moment with a very stupid criterion)
        left = []
        right = []
        splittable = False
        for endpoint in nffg.end_points:
            if endpoint.type == 'interface' and endpoint.name == "user":
                splittable = True
                left.append(endpoint)
                right = nffg.end_points + nffg.vnfs
                right.remove(endpoint)
                break
        # Try to split and match capabilities
        if splittable is True:
            domains_info = DomainsInformation().get_domain_info()
            if not domains_info:
                logging.debug("Domains information are not present, so it's not possible to split the graph")
                return node_list, nffg_list
            user_endpoint_domain_name = DomainsInformation().getDomainNamefromIP(node.ca_ip)
            if user_endpoint_domain_name is None:
                logging.debug("Domains information related to the user endpoint domain are not available, so it's not possible to split the graph")
                return node_list, nffg_list
            nffg1, nffg2 = nffg.split(left, right)
            #print(nffg1.getJSON())
            #print(nffg2.getJSON())
            gen_endpoints = nffg1.getAutogeneratedEndpoints()

            characterization = self.matchCapabilites(domains_info, len(gen_endpoints), user_endpoint_domain_name)
            
            if characterization:
                logging.debug("Graph can be split!")
                self.characterizeEndpoints(nffg1, nffg2, gen_endpoints, characterization)
                nffg_list.clear()
                nffg_list.append(nffg1)   
                nffg_list.append(nffg2)  
                # provisional
                node_list.append(Node().getNodeFromDomainID(self.checkEndpointLocation(nffg2)))
            else:
                logging.debug("Graph cannot be split because domains capabilities are not suitable for this graph")
            
        return node_list, nffg_list
    
    def characterizeEndpoints(self, nffg1, nffg2, gen_endpoints, characterization):
        #nffg1 will be instantiated in the domain that contains the user_endpoint
        i=0
        for element in characterization:
            if type(element) is DirectLink:
                nffg_1_endp = nffg1.getEndPoint(gen_endpoints[i].id)
                nffg_2_endp = nffg2.getEndPoint(gen_endpoints[i].id)
                #Characterization of single endpoints
                nffg_1_endp.type = "interface"
                nffg_1_endp.node = element.domain_1
                nffg_1_endp.interface = element.port_1
                nffg_2_endp.type = "interface"
                nffg_2_endp.node = element.domain_2
                nffg_2_endp.interface = element.port_2                
            else:
                raise TypeError("Only DirectLink characterizations are supported")
            i=i+1
        #print(nffg1.getJSON())
        #print(nffg2.getJSON())         
        
    def matchCapabilites(self, domains_info, number_of_links, user_endpoint_domain_name):
        # Can be done in a more elegant way
        characterization = None
        for domain_relationship in itertools.permutations(domains_info, 2):
            #print(domain_relationship)
            if domain_relationship[0]==user_endpoint_domain_name :
                print(domain_relationship)
                characterization = self.searchMatchesBetweenDomains(domains_info, domain_relationship[0], domain_relationship[1], number_of_links)
                if characterization:
                    break
        return characterization
                
    def searchMatchesBetweenDomains(self, domains_info, domain_name_1, domain_name_2, number_of_links):
        matches_found = 0
        #only direct links currently supported
        characterization = []
        domain_1 = domains_info[domain_name_1]
        for interface in domain_1.interfaces:
            #Check if a direct link between these two domains exists
            if interface.neighbor is not None and interface.neighbor != "internet":
                tmp = interface.neighbor.split('/')
                remote_domain_name = tmp[0]
                remote_interface_name = tmp[1]
                if remote_domain_name == domain_name_2 and remote_domain_name in domains_info:
                    remote_interface = domains_info[remote_domain_name].getInterface(remote_interface_name)
                    if remote_interface is not None and remote_interface.neighbor == domain_name_1+"/"+ interface.name:
                        #Direct link found between these two domains
                        print ("match found")
                        matches_found = matches_found + 1
                        characterization.append(DirectLink(domain_1.ip, interface.name, domains_info[remote_domain_name].ip, remote_interface_name))
                        if matches_found == number_of_links:
                            break
        if matches_found == number_of_links:
            print ("Characterization found")
            return characterization
        else:
            return None
                            
    """    
    def changeAvailabilityZone(self, nffg, availability_zone):
        for vnf in nffg.vnfs:
            vnf.availability_zone = availability_zone
    """
    
    def checkEndpointLocation(self, nffg):
        '''
        Define the node where to instantiate the nffg
        '''
        node = None
        for end_point in nffg.end_points:
            if end_point.node is not None:
                node = end_point.node
                break
            elif end_point.switch_id is not None:
                node = end_point.switch_id
                break
        if node is None:
            raise NodeNotFound("Unable to determine where to place this graph (endpoint.node or endpoint.switch_id missing)")
        return node
    
class DirectLink(object):
    def __init__(self, domain_1=None, port_1=None, domain_2=None, port_2=None):
        self.domain_1 = domain_1
        self.port_1 = port_1
        self.domain_2 = domain_2
        self.port_2 = port_2        
        
        
        
